#![allow(unused)]

use hvm::syntax::{Oper, Term, Rule};
use hvm::rulebook::sanitize_rule;
use std::error::Error;

// reduces term to Normal Form
pub fn normalize_term(term: &Term) -> Term {
    let mut term_copy = term.clone();
    reduce_weak(&mut term_copy);
    term_copy
}

// reduces term to Weak Head Normal Form
fn reduce_weak(term: &mut Term) {
    use Term::*;
    match term {
        U6O { numb } => {},
        F6O { numb } => {},
        Var { name } => {},
        Lam { name, body } => {},
        Ctr { name, args } => unreachable!("constructors are not generated by proptest"),
        Let { name, expr, body } => unreachable!("let expressions are not generated by proptest"),
        Sup { val0, val1 } => {},
        App { func, argm } => {
            reduce_weak(func);
            let func: &mut Term = func;
            match func {
                // (Î»x(body) a)
                // ------------ APP-LAM
                // x <- a
                // body
                Lam {name, body} => {
                    substitute(name, argm, body);
                    // take the body by value to avoid borrowing it and term at the same time
                    let new_body = std::mem::replace(body as &mut Term, Term::integer(0));
                    std::mem::replace(term, new_body);
                }
                _ => todo!("but wait, there's more!"),
            }
        },
        Dup { nam0, nam1, expr, body } => {
            todo!("wait for it");
        },
        _ => {},
    }
}

fn substitute(var_name: &str, expression: &mut Term, body: &mut Term) {
    //
}

pub fn sanitize_term(term: &Term) -> Result<Term, Box<dyn Error + Sync + Send + 'static>> {
    let rule = Rule::new(Term::constructor("HVM_MAIN_CALL", []), term.clone());
    Ok(*sanitize_rule(&rule)?.rhs)
}
