#![allow(unused)]

use hvm::syntax::{Oper, Term, Rule};
use hvm::rulebook::sanitize_rule;
use std::error::Error;

// reduces term to Normal Form
pub fn normalize_term(term: &Term) -> Term {
    let mut term_copy = term.clone();
    reduce_weak(&mut term_copy);
    term_copy
}

// reduces term to Weak Head Normal Form
fn reduce_weak(term: &mut Term) {
    use Term::*;
    loop {
        match term {
            U6O { numb } => break,
            F6O { numb } => break,
            Var { name } => break,
            Lam { name, body } => break,
            Ctr { name, args } => unreachable!("constructors are not generated by proptest"),
            Let { name, expr, body } => unreachable!("let expressions are not generated by proptest"),
            Sup { val0, val1 } => break,
            App { func, argm } => {
                reduce_weak(func);
                let func: &mut Term = func;
                match func {
                    // (Î»x(body) a)
                    // ------------ APP-LAM
                    // x <- a
                    // body
                    Lam {name, body} => {
                        substitute(name, argm, body);
                        // take the body by value to avoid borrowing it and term at the same time
                        let new_body = std::mem::replace(body as &mut Term, Term::integer(0));
                        std::mem::replace(term, new_body);
                    }
                    // ({a b} c)
                    // --------------- APP-SUP
                    // dup x0 x1 = c
                    // {(a x0) (b x1)}
                    Sup { val0, val1 } => {
                        let owned_val0 = std::mem::replace(val0 as &mut Term, Term::integer(0));
                        let owned_val1 = std::mem::replace(val1 as &mut Term, Term::integer(0));
                        let owned_argm = std::mem::replace(argm as &mut Term, Term::integer(0));
                        let body = Box::new(Sup {
                            val0: Box::new(Term::application( owned_val0, Term::variable("x0"))),
                            val1: Box::new(Term::application( owned_val1, Term::variable("x1"))),
                        });
                        let dupped = Dup { nam0: String::from("x0"), nam1: String::from("x1"), expr: Box::new(owned_argm), body};
                        std::mem::replace(term, dupped);
                    }
                    _ => {
                        eprintln!("cannot reduce an application over {}", func);
                        // allow applications with no associated rules, to match HVM behavior
                        break
                    },
                }
            },
            Dup { nam0, nam1, expr, body } => {
                todo!("wait for it");
            },
            _ => todo!("not there yet"),
        }
    }
}

// substitute the variable matching the given target name, with the expression in body
// returns true if a substitution was made inside body, and false otherwise
fn substitute(target: &str, expression: &mut Term, body: &mut Term) -> bool {
    use Term::*;
    match body {
        U6O { numb } => false,
        F6O { numb } => false,
        Var { name } if name == target => {
            std::mem::swap(body, expression);
            true
        },
        Var { name } => false,
        // only substitute if the variable isn't shadowed
        Lam { name, body } if name != target => substitute(target, expression, body),
        Lam { name, body } => false,
        Ctr { name, args } => unreachable!("constructors are not generated by proptest"),
        Let { name, expr, body } => unreachable!("let expressions are not generated by proptest"),
        Sup { val0, val1 } => substitute(target, expression, val0) || substitute(target, expression, val1),
        App { func, argm } => substitute(target, expression, func) || substitute(target, expression, argm),
        // only substitute in body if the variable isn't shadowed
        Dup { nam0, nam1, expr, body } if nam0 != target && nam1 != target => substitute(target, expression, expr) || substitute(target, expression, body),
        Dup { nam0, nam1, expr, body } => substitute(target, expression, expr),
        Op2 { oper, val0, val1 } => substitute(target, expression, val0) || substitute(target, expression, val1),
    }
}

pub fn sanitize_term(term: &Term) -> Result<Term, Box<dyn Error + Sync + Send + 'static>> {
    let rule = Rule::new(Term::constructor("HVM_MAIN_CALL", []), term.clone());
    Ok(*sanitize_rule(&rule)?.rhs)
}
