#![allow(unused)]

use hvm::syntax::{Oper, Term, Rule};
use hvm::rulebook::sanitize_rule;
use std::error::Error;

// reduces term to Normal Form
pub fn normalize_term(term: &Term) -> Term {
    let mut term_copy = term.clone();
    reduce_weak(&mut term_copy);
    term_copy
}

// reduces term to Weak Head Normal Form
fn reduce_weak(term: &mut Term) {
    use Term::*;
    loop {
        match term {
            U6O { numb } => break,
            F6O { numb } => break,
            Var { name } => break,
            Lam { name, body } => break,
            Ctr { name, args } => unreachable!("constructors are not generated by proptest"),
            Let { name, expr, body } => unreachable!("let expressions are not generated by proptest"),
            Sup { val0, val1 } => break,
            App { func, argm } => {
                reduce_weak(func);
                let func: &mut Term = func;
                match func {
                    // (Î»x(body) a)
                    // ------------ APP-LAM
                    // x <- a
                    // body
                    Lam {name, body} => {
                        substitute(name, argm, body);
                        // take the body by value to avoid borrowing it and term at the same time
                        let new_body = std::mem::replace(body as &mut Term, Term::integer(0));
                        std::mem::replace(term, new_body);
                    }
                    _ => todo!("but wait, there's more!"),
                }
            },
            Dup { nam0, nam1, expr, body } => {
                todo!("wait for it");
            },
            _ => {},
        }
    }
}

fn substitute(var_name: &str, expression: &mut Term, body: &mut Term) {
    //
}

pub fn sanitize_term(term: &Term) -> Result<Term, Box<dyn Error + Sync + Send + 'static>> {
    let rule = Rule::new(Term::constructor("HVM_MAIN_CALL", []), term.clone());
    Ok(*sanitize_rule(&rule)?.rhs)
}
