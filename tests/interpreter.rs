#![allow(unused)]

use hvm::syntax::{Oper, Term, Rule};
use hvm::rulebook::sanitize_rule;
use std::error::Error;

// reduces term to Normal Form
pub fn normalize_term(term: &Term) -> Term {
    let mut term_copy = term.clone();
    reduce_weak(&mut term_copy);
    term_copy
}

// reduces term to Weak Head Normal Form
fn reduce_weak(term: &mut Term) {
    use Term::*;
    loop {
        match term {
            U6O { numb } => break,
            F6O { numb } => break,
            Var { name } => break,
            Lam { name, body } => break,
            Ctr { name, args } => unreachable!("constructors are not generated by proptest"),
            Let { name, expr, body } => unreachable!("let expressions are not generated by proptest"),
            Sup { val0, val1 } => break,
            App { func, argm } => {
                // reduce func so that we know how to reduce the application
                reduce_weak(func);
                let func: &mut Term = func;
                match func {
                    // (位x(body) a)
                    // ------------ APP-LAM
                    // x <- a
                    // body
                    Lam {name, body} => {
                        era_aware_substitute(name, argm, body);
                        // take the body by value to avoid borrowing it and term at the same time
                        let new_body = std::mem::replace(body as &mut Term, Term::integer(0));
                        std::mem::replace(term, new_body);
                    }
                    // ({a b} c)
                    // --------------- APP-SUP
                    // dup x0 x1 = c
                    // {(a x0) (b x1)}
                    Sup { val0, val1 } => {
                        let owned_val0 = std::mem::replace(val0 as &mut Term, Term::integer(0));
                        let owned_val1 = std::mem::replace(val1 as &mut Term, Term::integer(0));
                        let owned_argm = std::mem::replace(argm as &mut Term, Term::integer(0));
                        let body = Box::new(Sup {
                            val0: Box::new(Term::application( owned_val0, Term::variable("x0"))),
                            val1: Box::new(Term::application( owned_val1, Term::variable("x1"))),
                        });
                        let dupped = Dup { nam0: String::from("x0"), nam1: String::from("x1"), expr: Box::new(owned_argm), body};
                        std::mem::replace(term, dupped);
                    }
                    _ => {
                        eprintln!("cannot reduce an application over {}", func);
                        // allow applications with no associated rules, to match HVM behavior
                        break
                    },
                }
            },
            Dup { nam0, nam1, expr, body } => {
                // reduce expr so that we know what we are duplicating
                reduce_weak(expr);
                let expr: &mut Term = expr;
                match expr {
                    // dup a b = 位x(body)
                    // ------------------ DUP-LAM
                    // a <- 位x0(b0)
                    // b <- 位x1(b1)
                    // x <- {x0 x1}
                    // dup b0 b1 = body
                    Lam {name, body: inner_body} => {
                        let mut sup = Sup {
                            val0: Box::new(Term::variable("x0")),
                            val1: Box::new(Term::variable("x1")),
                        };
                        era_aware_substitute(name, &mut sup, inner_body);

                        era_aware_substitute(nam0, &mut Term::lambda("x0", Term::variable("b0")), body);
                        era_aware_substitute(nam1, &mut Term::lambda("x1", Term::variable("b1")), body);
                        let owned_inner_body = std::mem::replace(inner_body as &mut Term, Term::integer(0));
                        let owned_body = std::mem::replace(body as &mut Term, Term::integer(0));
                        let new_dup = Dup { nam0: String::from("b0"), nam1: String::from("b1"), expr: Box::new(owned_inner_body), body: Box::new(owned_body)};
                        std::mem::replace(term, new_dup);
                    },
                    _ => todo!("but wait, theres more!")
                }
            },
            _ => todo!("not there yet"),
        }
    }
}

// behaves like substitute, but returns early when the target name is ERA
fn era_aware_substitute(target: &str, expression: &mut Term, body: &mut Term) {
    if target != "*" {
        substitute(target, expression, body)
    }
}

// substitute the variable matching the given target name, with the expression in body
fn substitute(target: &str, expression: &mut Term, body: &mut Term) {
    use Term::*;
    match body {
        U6O { numb } => {},
        F6O { numb } => {},
        Var { name } if name == target => std::mem::swap(body, expression),
        Var { name } => {},
        // only substitute if the variable isn't shadowed
        Lam { name, body } if name != target => substitute(target, expression, body),
        Lam { name, body } => {},
        Ctr { name, args } => unreachable!("constructors are not generated by proptest"),
        Let { name, expr, body } => unreachable!("let expressions are not generated by proptest"),
        Sup { val0, val1 } => {
            substitute(target, expression, val0);
            substitute(target, expression, val1);
        },
        App { func, argm } => {
            substitute(target, expression, func);
            substitute(target, expression, argm);
        },
        // only substitute in body if the variable isn't shadowed
        Dup { nam0, nam1, expr, body } if nam0 != target && nam1 != target => {
            substitute(target, expression, expr);
            substitute(target, expression, body);
        },
        Dup { nam0, nam1, expr, body } => substitute(target, expression, expr),
        Op2 { oper, val0, val1 } => {
            substitute(target, expression, val0);
            substitute(target, expression, val1);
        },
    }
}

pub fn sanitize_term(term: &Term) -> Result<Term, Box<dyn Error + Sync + Send + 'static>> {
    let rule = Rule::new(Term::constructor("HVM_MAIN_CALL", []), term.clone());
    Ok(*sanitize_rule(&rule)?.rhs)
}
